var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules=[ClassicalSpinMC]","category":"page"},{"location":"api/#ClassicalSpinMC.H5","page":"API","title":"ClassicalSpinMC.H5","text":"const H5 = Union{HDF5.File,HDF5.Group}\n\nUsed to define an alias for a HDF5 File or Group.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.MatrixObs","page":"API","title":"ClassicalSpinMC.MatrixObs","text":"const MatrixObs\n\nAlias for either BinnedMatrixObs or FullMatrixObs.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.VectorObs","page":"API","title":"ClassicalSpinMC.VectorObs","text":"const VectorObs\n\nAlias for either BinnedVectorObs or FullVectorObs.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.updateParameterDict","page":"API","title":"ClassicalSpinMC.updateParameterDict","text":"const updateParameterDict\n\nA dictionary used to lookup the initial parameters for  spin update methods.\n\n\n\n\n\n","category":"constant"},{"location":"api/#ClassicalSpinMC.AbstractObservables","page":"API","title":"ClassicalSpinMC.AbstractObservables","text":"abstract type AbstractObservables\n\nThis is a struct to store Observables measured during the MonteCarlo run.\n\n!!! note In order to measure observables other than the built-in Observables type or a subset of it, you may create a subtype of AbstractObservables  such as MyObservables and define the following functions.\n\n1.performMeasurements!(observables::MyObservables, lattice::T, energy::Float64) where {T<:Lattice}\n\n2.performPostMeasurements!(observables::MyObservables, lattice::T, Î²::Float64) where {T<:Lattice}\n\nDepending on the complexity of your type, you may also have to define \n\n1.writeObservables!(fn:H5, obs::MyObservables)\n\n2.readObservables\n\nif the general function cannot handle those types.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.BinnedMatrixObs","page":"API","title":"ClassicalSpinMC.BinnedMatrixObs","text":"const BinnedMatrixObs\n\nAlias for LogBinner storing a Matrix{Float64}.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.BinnedObs","page":"API","title":"ClassicalSpinMC.BinnedObs","text":"const BinnedObs\n\nAlias for a LogBinner storing a Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.BinnedVectorObs","page":"API","title":"ClassicalSpinMC.BinnedVectorObs","text":"const BinnedVectorObs\n\nAlias for a LogBinner storing a Vector{Float64}.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.FullMatrixObs","page":"API","title":"ClassicalSpinMC.FullMatrixObs","text":"const FullMatrixObs\n\nAlias for FullBinner storing a Matrix{Float64}.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.FullObs","page":"API","title":"ClassicalSpinMC.FullObs","text":"const FullObs\n\nAlias for a FullBinner storing a Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.FullVectorObs","page":"API","title":"ClassicalSpinMC.FullVectorObs","text":"const FullVectorObs\n\nAlias for a FullBinner storing a Vector{Float64}.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.Lattice","page":"API","title":"ClassicalSpinMC.Lattice","text":"struct Lattice\n\nContains information about the current spin configuration and  all energy terms such as exchange interactions.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.Lattice-Union{Tuple{D}, Tuple{UnitCell{D}, Tuple{Vararg{Int64, D}}}} where D","page":"API","title":"ClassicalSpinMC.Lattice","text":"function Lattice(uc::UnitCell{D}, L::NTuple{D,Int}) where {D}\n\nGenerates a Lattice from a UnitCell with periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.MonteCarlo","page":"API","title":"ClassicalSpinMC.MonteCarlo","text":"mutable struct MonteCarlo\n\nThis is used to store all information about a Monte Carlo run.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.MonteCarlo-Union{Tuple{O}, Tuple{T}, Tuple{T, MonteCarloParameters, O}} where {T<:Lattice, O<:AbstractObservables}","page":"API","title":"ClassicalSpinMC.MonteCarlo","text":"function MonteCarlo(lattice::T, parameters::MonteCarloParameters,\nobservables::Observables) where {T<:Lattice}\n\nConstructor that generates a MonteCarloStatistics struct automatically.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.MonteCarlo-Union{Tuple{T}, Tuple{T, MonteCarloParameters}} where T<:Lattice","page":"API","title":"ClassicalSpinMC.MonteCarlo","text":"function MonteCarlo(lattice::T, parameters::MonteCarloParameters) where {T<:Lattice}\n\nConstructor that generates a MonteCarloStatistics struct and built-in  Observables struct automatically.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.MonteCarloAnnealing","page":"API","title":"ClassicalSpinMC.MonteCarloAnnealing","text":"mutable struct MonteCarloAnnealing\n\nThis is a wrapper around MonteCarlo and is used to store the  multiple Monte Carlo structs created during a simulated annealing run.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.MonteCarloAnnealing-Tuple{MonteCarlo, Vector{Float64}}","page":"API","title":"ClassicalSpinMC.MonteCarloAnnealing","text":"function MonteCarloAnnealing(mc::MonteCarlo, betas::Vector{Float64})\n\nConstructor for generating a MonteCarloAnnealing struct used for  Simulated Annealing runs.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.MonteCarloExchange","page":"API","title":"ClassicalSpinMC.MonteCarloExchange","text":"mutable struct MonteCarloExchange\n\nThis is a wrapper around MonteCarlo and is used to store the  multiple Monte Carlo structs and resources needed for distributed  computing during a Replica Exchange (Parallel tempering) run.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.MonteCarloExchange-Tuple{MonteCarlo, Vector{Float64}}","page":"API","title":"ClassicalSpinMC.MonteCarloExchange","text":"function MonteCarloExchange(mc::MonteCarlo, betas::Vector{Float64})\n\nConstructor for generating a MonteCarloExchange struct used for  Replica Exchange (Parallel tempering) runs.\n\nwarning: Available workers\nAt the present time, this module uses workers 1:length(betas). Please verify that these workers are created and available before  creating this struct. At a future time, arbritary workers and  their automatic creation may be supported.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.MonteCarloParameters","page":"API","title":"ClassicalSpinMC.MonteCarloParameters","text":"mutable struct MonteCarloParameters\n\nThis is used to store any parameters used to configure the Monte Carlo run.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.MonteCarloParameters-Tuple{Float64, Int64, Int64}","page":"API","title":"ClassicalSpinMC.MonteCarloParameters","text":"function MonteCarloParameters(\nbeta::Float64,\nthermalizationSweeps::Int,\nmeasurementSweeps::Int)\n\nConstructor that uses reasonable defaults for MonteCarloParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.MonteCarloStatistics","page":"API","title":"ClassicalSpinMC.MonteCarloStatistics","text":"mutable struct MonteCarloStatistics\n\nThis is used to store information regarding the statistics gathered during the Monte Carlo run.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.Observables","page":"API","title":"ClassicalSpinMC.Observables","text":"mutable struct Observables\n\nBuilt-in Observables type that measures simple observables and  serves as a template for custom observable structs.\n\nnote: Mandatory fields\nIn order to use replica exchange (parallel tempering) the labels and replicaAcceptance fields are mandatory.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.Observables-Tuple{T} where T<:Lattice","page":"API","title":"ClassicalSpinMC.Observables","text":"function Observables(lattice::T) where {T<:Lattice}\n\nGenerates an Observables object for a given Lattice object.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.UnitCell","page":"API","title":"ClassicalSpinMC.UnitCell","text":"mutable struct UnitCell\n\nThis is used to represent a UnitCell struct.  For further computation it must first be converted into a Lattice struct.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClassicalSpinMC.UnitCell-Union{Tuple{Vararg{SVector{D, Float64}, D}}, Tuple{D}} where D","page":"API","title":"ClassicalSpinMC.UnitCell","text":"function UnitCell(primitive::Vararg{SVector{D,Float64},D})\n\nUnitCell constructor that accepts D number of D dimensional SVectors as input to use as primitives. \n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.UnitCell-Union{Tuple{Vararg{Tuple{Vararg{Float64, D}}, D}}, Tuple{D}} where D","page":"API","title":"ClassicalSpinMC.UnitCell","text":"function UnitCell(primitive::Vararg{NTuple{D,Float64},D})\n\nUnitCell constructor that accepts D number of D dimensional NTuples for primitives that get converted to SVectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.addAnisotropy!-Union{Tuple{F}, Tuple{D}, Tuple{UnitCell{D}, F, Vector{Float64}}} where {D, F<:Function}","page":"API","title":"ClassicalSpinMC.addAnisotropy!","text":"function addAnisotropy!(unitcell::UnitCell{D}, func::F, funcParameters::Vector{Float64}) where {D,F<:Function)\n\nAdds an anisotropy function to the UnitCell definition along with any parameters that need to be passed  along to the anisotropy function. The default anisotropy function is identity.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.addBasisSite!-Union{Tuple{D}, Tuple{UnitCell{D}, Array{SVector{D, Float64}, 1}}} where D","page":"API","title":"ClassicalSpinMC.addBasisSite!","text":"function addBasisSite!(unitcell::UnitCell{D}, positions::Vector{SVector{D,Float64}}) where {D}\n\nConvenience function that accepts multiple positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.addBasisSite!-Union{Tuple{D}, Tuple{UnitCell{D}, Array{Tuple{Vararg{Float64, D}}, 1}}} where D","page":"API","title":"ClassicalSpinMC.addBasisSite!","text":"function addBasisSite!(unitcell::UnitCell{D}, positions::Vector{NTuple{D,Float64}}) where {D}\n\nConvenience function that accepts multiple positions and converts them into SVector internally.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.addBasisSite!-Union{Tuple{D}, Tuple{UnitCell{D}, SVector{D, Float64}}} where D","page":"API","title":"ClassicalSpinMC.addBasisSite!","text":"function addBasisSite!(unitcell::UnitCell{D}, position::SVector{D,Float64}) where {D}\n\nAdds a new basis site to the given unitcell at the given position with no self-interaction and no magnetic field.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.addBasisSite!-Union{Tuple{D}, Tuple{UnitCell{D}, Tuple{Vararg{Float64, D}}}} where D","page":"API","title":"ClassicalSpinMC.addBasisSite!","text":"function addBasisSite!(unitcell::UnitCell{D}, position::NTuple{D,Float64}) where {D}\n\nConvenience function that accepts position as an NTuple and converts it to an SVector internally.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.addInteraction!-Union{Tuple{D}, Tuple{UnitCell{D}, Int64, Int64, Matrix{Float64}}, Tuple{UnitCell{D}, Int64, Int64, Matrix{Float64}, Tuple{Vararg{Int64, D}}}} where D","page":"API","title":"ClassicalSpinMC.addInteraction!","text":"function addInteraction!(unitcell::UnitCell{D}, b1::Int, b2::Int, M::Matrix{Float64}, offset::NTuple{D,Int}=Tuple(zeros(Int, D))) where {D}\n\nConvenience function that converts to SMatrix and creates the b1 and b2 pair automatically.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.addInteraction!-Union{Tuple{D}, Tuple{UnitCell{D}, Int64, Int64, SMatrix{3, 3, Float64, 9}}, Tuple{UnitCell{D}, Int64, Int64, SMatrix{3, 3, Float64, 9}, Tuple{Vararg{Int64, D}}}} where D","page":"API","title":"ClassicalSpinMC.addInteraction!","text":"function addInteraction!(unitcell::UnitCell{D}, b1::Int, b2::Int, M::SMatrix{3,3,Float64,9}, offset::NTuple{D,Int}=Tuple(zeros(Int, D))) where {D}\n\nConvenience function that creates the b1 and b2 pair automatically.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.addInteraction!-Union{Tuple{D}, Tuple{UnitCell{D}, Int64, Vector{Int64}, SMatrix{3, 3, Float64, 9}, Array{Tuple{Vararg{Int64, D}}, 1}}} where D","page":"API","title":"ClassicalSpinMC.addInteraction!","text":"function addInteraction!(unitcell::UnitCell{D}, b1::Int, b2s::Vector{Int}, M::SMatrix{3,3,Float64,9}, offsets::Vector{NTuple{D,Int}}) where {D}\n\nConvenience function that adds the same interaction for  a vector of b2 and offset values pairwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.addInteraction!-Union{Tuple{D}, Tuple{UnitCell{D}, Pair{Int64, Int64}, SMatrix{3, 3, Float64, 9}}, Tuple{UnitCell{D}, Pair{Int64, Int64}, SMatrix{3, 3, Float64, 9}, Tuple{Vararg{Int64, D}}}} where D","page":"API","title":"ClassicalSpinMC.addInteraction!","text":"function addInteraction!(unitcell::UnitCell{D}, b::Pair{Int,Int}, M::SMatrix{3,3,Float64,9}, offset::NTuple{D,Int}=Tuple(zeros(Int, D))) where {D}\n\nAdds an interaction between spin_1 located at basis site b_1 of the given unitcell and spin_2  at basis site b_2 in a unit cell that is offset by offset lattice vectors.  The exchange energy is calculated as spin_1'M.spin_2. \n\nPlease note that local interactions that involve the same site will be automatically  added as an on site interaction using setInteractionOnSite!(...).\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.anneal!-Union{Tuple{M}, Tuple{M, Vector{Float64}}} where M<:MonteCarlo","page":"API","title":"ClassicalSpinMC.anneal!","text":"function anneal!(mc::M, betas::Vector{Float64}) where {M<:MonteCarlo}\n\nAnneals a given MonteCarlo object through the given array of betas  without creating intermediate MonteCarloAnnealing and MonteCarlo objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.calcTriangles-Union{Tuple{Lattice{D, N}}, Tuple{N}, Tuple{D}} where {D, N}","page":"API","title":"ClassicalSpinMC.calcTriangles","text":"function calcTriangles(lattice::Lattice{D,N}) where {D,N}\n\nReturns a list of all unique triangles found in the lattice consisting of the sites comprising the triangle in ascending order.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.conicalUpdate","page":"API","title":"ClassicalSpinMC.conicalUpdate","text":"function conicalUpdate(v::SVector{3,Float64}, t::Float64, rng=Random.GLOBAL_RNG)\n\nGenerates a random point on a unit sphere restricted in a cone defined as  being centered around the vector v and an angle t. For t=pi this is equivalent to any other sphere point picking method.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClassicalSpinMC.createChannels-Tuple{}","page":"API","title":"ClassicalSpinMC.createChannels","text":"function createChannels()\n\nCreates the RemoteChannels required for worker-worker communication used in  Replica Exchange (Parallel Tempering) runs.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.dimension-Union{Tuple{UnitCell{D}}, Tuple{D}} where D","page":"API","title":"ClassicalSpinMC.dimension","text":"function dimension(unitcell::UnitCell{D}) where {D}\n\nUtility function to get the dimensionality of a UnitCell struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.exchangeEnergy-Tuple{SVector{3, Float64}, SMatrix{3, 3, Float64, 9}, SVector{3, Float64}}","page":"API","title":"ClassicalSpinMC.exchangeEnergy","text":"function exchangeEnergy(s1::SVector{3,Float64}, M::SMatrix{3,3,Float64,9}, s2::SVector{3,Float64})\n\nCalculates the energy contribution due to exchange terms.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getAnisotropy-Union{Tuple{F}, Tuple{N}, Tuple{D}, Tuple{F, Lattice{D, N}}} where {D, N, F<:Function}","page":"API","title":"ClassicalSpinMC.getAnisotropy","text":"function getAnisotropy(func::F, lattice::Lattice{D,N})::Float64 where {D,N,F<:Function}\n\nCalculates the anisotropy energy term for the full lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getAnisotropy-Union{Tuple{N}, Tuple{D}, Tuple{typeof(identity), Lattice{D, N}}} where {D, N}","page":"API","title":"ClassicalSpinMC.getAnisotropy","text":"function getAnisotropy(::typeof(identity), lattice::Lattice{D,N})::Float64 where {D,N}\n\nDefault method for returning zero in case of no-anisotropy for the full lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getAnisotropy-Union{Tuple{P}, Tuple{F}, Tuple{F, SVector{3, Float64}, Tuple{Vararg{Float64, P}}}} where {F<:Function, P}","page":"API","title":"ClassicalSpinMC.getAnisotropy","text":"function getAnisotropy(func::F, spin::SVector{3,Float64}, parameters::NTuple{P,Float64})::Float64 where {F<:Function,P}\n\nCalculates the anisotropy energy term for a particular spin.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getAnisotropy-Union{Tuple{P}, Tuple{typeof(identity), SVector{3, Float64}, Tuple{Vararg{Float64, P}}}} where P","page":"API","title":"ClassicalSpinMC.getAnisotropy","text":"function getAnisotropy(::typeof(identity), spin::SVector{3,Float64}, parameters::NTuple{P,Float64})::Float64 where {P}\n\nDefault method for returning zero in case of no-anisotropy for a particular spin.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getChirality-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Vector{Vector{Int64}}}} where {D, N}","page":"API","title":"ClassicalSpinMC.getChirality","text":"function getChirality(lattice::Lattice{D,N}, siteList::Vector{Vector{Int64}}) where {D,N}\n\nGiven a siteList of triangles in the lattice, computes the chirality of the lattice, where the chirality is defined as the vector triple product of spins on a triangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getCorrelation-Union{Tuple{Lattice{D, N}}, Tuple{N}, Tuple{D}} where {D, N}","page":"API","title":"ClassicalSpinMC.getCorrelation","text":"function getCorrelation(lattice::Lattice{D,N}) where {D,N}\n\nMeasures the two-point correlation for each pair of sites in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getEnergy-Union{Tuple{Lattice{D, N}}, Tuple{N}, Tuple{D}} where {D, N}","page":"API","title":"ClassicalSpinMC.getEnergy","text":"function getEnergy(lattice::Lattice{D,N})::Float64 where {D,N}\n\nCalculates the energy of the current spin configuration of the lattice  based on all terms defined such as exchange, onsite, field and ansiotropy terms.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getEnergyDifference-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Int64, SVector{3, Float64}}} where {D, N}","page":"API","title":"ClassicalSpinMC.getEnergyDifference","text":"function getEnergyDifference(lattice::Lattice{D,N}, site::Int, newState::SVector{3,Float64})::Float64 where {D,N}\n\nPerformant method for calculating the energy difference when updating a site into a newState due to all terms such as exchange, onsite, field and ansiotropy terms.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getInteractionField-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Int64}} where {D, N}","page":"API","title":"ClassicalSpinMC.getInteractionField","text":"function getInteractionField(lattice::Lattice{D,N}, site::Int)::SVector{3,Float64} where {D,N}\n\nInterface function to get the magnetic field on a particular site.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getInteractionMatrices-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Int64}} where {D, N}","page":"API","title":"ClassicalSpinMC.getInteractionMatrices","text":"function getInteractionMatrices(lattice::Lattice{D,N}, site::Int)::NTuple{N,SMatrix{3,3,Float64,9}} where {D,N}\n\nInterface function to get the exchange interactions on a particular site.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getInteractionOnsite-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Int64}} where {D, N}","page":"API","title":"ClassicalSpinMC.getInteractionOnsite","text":"function getInteractionOnsite(lattice::Lattice{D,N}, site::Int)::SMatrix{3,3,Float64,9} where {D,N}\n\nInterface function to get the on-site interactions on a particular site.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getInteractionSites-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Int64}} where {D, N}","page":"API","title":"ClassicalSpinMC.getInteractionSites","text":"function getInteractionSites(lattice::Lattice{D,N}, site::Int)::NTuple{N,Int} where {D,N}\n\nInterface function to get the sites that interact with a particular site  via exchange terms.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getMagnetization-Union{Tuple{Lattice{D, N}}, Tuple{N}, Tuple{D}} where {D, N}","page":"API","title":"ClassicalSpinMC.getMagnetization","text":"function getMagnetization(lattice::Lattice{D,N}) where {D,N}\n\nMeasures the Magnetization of the lattice spin configuration.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getMagnetizationPerSite-Union{Tuple{Lattice{D, N}}, Tuple{N}, Tuple{D}} where {D, N}","page":"API","title":"ClassicalSpinMC.getMagnetizationPerSite","text":"function getMagnetizationPerSite(lattice::Lattice{D,N}) where {D,N}\n\nMeasures the Magnetization for each type of basis site in the unitcell seperately.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getSitePosition-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Int64}} where {D, N}","page":"API","title":"ClassicalSpinMC.getSitePosition","text":"function getSitePosition(lattice::Lattice{D,N}, site::Int)::SVector{D,Float64} where {D,N}\n\nInterface function to get the position of a particular site.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.getSpin-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Int64}} where {D, N}","page":"API","title":"ClassicalSpinMC.getSpin","text":"function getSpin(lattice::Lattice{D,N}, site::Int) where {D,N}\n\nInterface function to get the spin at a particular site.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.initSpinConfiguration!-Union{Tuple{MonteCarlo{T}}, Tuple{T}} where T<:Lattice","page":"API","title":"ClassicalSpinMC.initSpinConfiguration!","text":"function initSpinConfiguration!(mc::MonteCarlo{T}) where {T<:Lattice}\n\nInitialize the spin configuration for a Monte Carlo struct by using the  function specified in MonteCarloParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.initSpinConfiguration!-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Function}, Tuple{Lattice{D, N}, Function, Any}} where {D, N}","page":"API","title":"ClassicalSpinMC.initSpinConfiguration!","text":"function initSpinConfiguration!(lattice::Lattice{D,N}, f::Function, rng=Random.GLOBAL_RNG) where {D,N}\n\nInitialize the spin configuration of a lattice using the passed function.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.initSpinConfiguration!-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, typeof(conicalUpdate)}, Tuple{Lattice{D, N}, typeof(conicalUpdate), Any}} where {D, N}","page":"API","title":"ClassicalSpinMC.initSpinConfiguration!","text":"function initSpinConfiguration!(lattice::Lattice{D,N}, f::typeof(conicalUpdate), rng=Random.GLOBAL_RNG) where {D,N}\n\nInitialize the spin configuration of a lattice using the conicalUpdate method.\n\nwarning: Pre-initialize for conical updates\nSince conicalUpdate forms a cone around a point on a unit sphere, it cannot be used to reliably initialize a spin configuration unless it was already initialized  using a different method first. This method is provided only for consistency.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.localSweep-Union{Tuple{T}, Tuple{Function, MonteCarlo{T}, Float64}} where T<:Lattice","page":"API","title":"ClassicalSpinMC.localSweep","text":"function localSweep(::Function, mc::MonteCarlo{T}, energy::Float64) where {T<:Lattice}\n\nPerforms a local sweep on the current spin configuration, using the function specified in  MonteCarloParameters. This covers only the case where the update function takes the rng as it's only parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.localSweep-Union{Tuple{T}, Tuple{MonteCarlo{T}, Float64}} where T<:Lattice","page":"API","title":"ClassicalSpinMC.localSweep","text":"function localSweep(mc::MonteCarlo{T}, energy::Float64) where {T<:Lattice}\n\nPerforms a local sweep on the current spin configuration using the method specified in MonteCarloParameters. This is the top-level method.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.localSweep-Union{Tuple{T}, Tuple{typeof(conicalUpdate), MonteCarlo{T}, Float64}} where T<:Lattice","page":"API","title":"ClassicalSpinMC.localSweep","text":"function localSweep(::typeof(conicalUpdate), mc::MonteCarlo{T}, energy::Float64) where {T<:Lattice}\n\nPerforms a local sweep on the current spin configuration using the conicalUpdate method.  This is a specialization of the method and not the general case.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.localUpdate-Union{Tuple{P}, Tuple{T}, Tuple{MonteCarlo{T, P}, Int64, SVector{3, Float64}}} where {T<:Lattice, P<:MonteCarloParameters}","page":"API","title":"ClassicalSpinMC.localUpdate","text":"function localUpdate(mc::MonteCarlo{T,P}, proposalSite::Int64, newSpinState::SVector{3,Float64}) where {T<:Lattice,P<:MonteCarloParameters}\n\nPerforms a local update on the current spin configuration, using the proposed new spin state.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.marsagliaSphereUpdate","page":"API","title":"ClassicalSpinMC.marsagliaSphereUpdate","text":"function marsagliaSphereUpdate(rng=Random.GLOBAL_RNG)\n\nGenerates a random point on a unit sphere using the marsaglia method.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClassicalSpinMC.microcanonicalRotation-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Int64}} where {D, N}","page":"API","title":"ClassicalSpinMC.microcanonicalRotation","text":"function microcanonicalRotation(lattice::Lattice{D,N}, site::Int) where {D,N}\n\nPerforms an Overrelaxation step on the lattice in a deterministic way by  using a Ï rotation.\n\nnote: Assumptions on interactions and ansiotropy\nThis assumes that there are no anisotropy contributions  and no self interactions for the lattice object.  For performance reasons, these checks are performed seperately.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.microcanonicalRotationRandom-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Int64}, Tuple{Lattice{D, N}, Int64, Any}} where {D, N}","page":"API","title":"ClassicalSpinMC.microcanonicalRotationRandom","text":"function microcanonicalRotationRandom(lattice::Lattice{D,N}, site::Int, rng=Random.GLOBAL_RNG) where {D,N}\n\nPerforms an Overrelaxation step on the lattice in a non-deterministic way by  using a random rotation.\n\nnote: Assumptions on interactions and anisotropy\nThis assumes that there are no anisotropy contributions  and no self interactions for the lattice object.  For performance reasons, these checks are performed seperately.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.microcanonicalSweep!-Union{Tuple{MonteCarlo{T}}, Tuple{T}} where T<:Lattice","page":"API","title":"ClassicalSpinMC.microcanonicalSweep!","text":"function microcanonicalSweep!(mc::MonteCarlo{T}) where {T<:Lattice}\n\nPerforms a microcanonical (overrelaxation) sweep on current spin configuration, based on parameters from MonteCarloParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.microcanonicalSweep!-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Int64}, Tuple{Lattice{D, N}, Int64, Any}} where {D, N}","page":"API","title":"ClassicalSpinMC.microcanonicalSweep!","text":"function microcanonicalSweep!(lattice::Lattice{D,N}, rounds::Int, rng=Random.GLOBAL_RNG) where {D,N}\n\nPerforms a microcanonical (overrelaxation) sweep on the current spin configuration. This is particularly useful for low-temperature simulations where the spins get stuck.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.performMeasurements!-Union{Tuple{T}, Tuple{Observables, T, Float64}} where T<:Lattice","page":"API","title":"ClassicalSpinMC.performMeasurements!","text":"function performMeasurements!(observables::Observables, lattice::T, energy::Float64) where {T<:Lattice}\n\nPerforms measurements and is called during measurement sweeps. \n\nnote: Energy measurement\nSince the current energy of the spin configuration is calculated as part of the  Monte Carlo sweep, it is passed on directly.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.performMeasurements!-Union{Tuple{T}, Tuple{O}, Tuple{O, T, Float64}} where {O<:AbstractObservables, T<:Lattice}","page":"API","title":"ClassicalSpinMC.performMeasurements!","text":"function performMeasurements!(observables::Observables, lattice::T, energy::Float64) where {T<:Lattice}\n\nGeneric method to perform measurements. \n\nFor every field (F) in observables, gets the method \"get(F)\" from Main.\n\n!!! note \"Performance\" This method is not performant since it calls a seperate method  for all observables regardless of any dependence between them.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.performPostMeasurements!-Union{Tuple{T}, Tuple{Observables, T, Float64}} where T<:Lattice","page":"API","title":"ClassicalSpinMC.performPostMeasurements!","text":"function performPostMeasurements!(observables::Observables, lattice::T, Î²::Float64) where {T<:Lattice}\n\nPerforms measurements and is called after all Monte Carlo sweeps are performed.  It is intended to do any post measurements based on the collect observables or final state of the system. \n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.piRotation-Tuple{SVector{3, Float64}, SVector{3, Float64}}","page":"API","title":"ClassicalSpinMC.piRotation","text":"function piRotation(spin::SVector{3,Float64}, axis::SVector{3,Float64})\n\nSpecial case of rotateAboutAxis for a rotation by an angle Ï.\n\nnote: Assumptions on normalization\nThis assumes that the vector and axis are normalized  for performance reasons.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.printStatistics!-Union{Tuple{MonteCarlo{T}}, Tuple{T}} where T<:Lattice","page":"API","title":"ClassicalSpinMC.printStatistics!","text":"function printStatistics!(mc::MonteCarlo{T}; replica=false) where {T<:Lattice}\n\nPrint statistics from the current status of the MonteCarlo run.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.readCheckpoint-Tuple{String}","page":"API","title":"ClassicalSpinMC.readCheckpoint","text":"function readCheckpoint(filename::String)\n\nInterface function to read a MonteCarlo checkpoint.\n\nwarning: Checkpoints\nCheckpoints use Serialization and thus are not recommended for long term storage  as they may not be supported on a different Julia version.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.readLattice-Tuple{Union{HDF5.File, HDF5.Group}}","page":"API","title":"ClassicalSpinMC.readLattice","text":"function readLattice(fn::H5)\n\nReads the Lattice from a H5 object.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.readMonteCarlo-Tuple{String}","page":"API","title":"ClassicalSpinMC.readMonteCarlo","text":"function readMonteCarlo(filename::String)\n\nReads the MonteCarlo object from a HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.readMonteCarlo-Tuple{Union{HDF5.File, HDF5.Group}}","page":"API","title":"ClassicalSpinMC.readMonteCarlo","text":"function readMonteCarlo(fn::H5)\n\nReads the MonteCarlo object from a H5 object.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.readMonteCarloParameters-Tuple{Union{HDF5.File, HDF5.Group}}","page":"API","title":"ClassicalSpinMC.readMonteCarloParameters","text":"function readMonteCarloParameters(fn::H5)\n\nReads the MonteCarloParameters from a H5 object.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.readMonteCarloStatistics-Tuple{Union{HDF5.File, HDF5.Group}}","page":"API","title":"ClassicalSpinMC.readMonteCarloStatistics","text":"function readMonteCarloStatistics(fn::H5)\n\nReads the MonteCarloStatistics from a H5 object.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.readObservables-Tuple{Union{HDF5.File, HDF5.Group}}","page":"API","title":"ClassicalSpinMC.readObservables","text":"function readObservables(fn::Union{HDF5.File,HDF5.Group})\n\nReads the built-in Observables from a H5 object.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.readUnitcell-Tuple{Union{HDF5.File, HDF5.Group}}","page":"API","title":"ClassicalSpinMC.readUnitcell","text":"function readUnitcell(fn::H5)\n\nReads the unitcell from a H5 object.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.replicaExchange!-Union{Tuple{T}, Tuple{MonteCarlo{T}, Float64, Vector{Float64}, Any, Any, Any}} where T<:Lattice","page":"API","title":"ClassicalSpinMC.replicaExchange!","text":"function replicaExchange!(mc::MonteCarlo{T}, energy::Float64, betas::Vector{Float64}, channelsUp, channelsDown, label) where {T<:Lattice}\n\nPerforms a replica exchange sweep based on parameters from the MonteCarlo object on the current worker.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.resetBasis!-Union{Tuple{UnitCell{D}}, Tuple{D}} where D","page":"API","title":"ClassicalSpinMC.resetBasis!","text":"function resetBasis!(unitcell::UnitCell{D}) where {D}\n\nResets the basis of a unitcell and all quantities that depend on the basis.  This includes the interactions and interaction fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.rotateAboutAxis-Tuple{SVector{3, Float64}, SVector{3, Float64}, Float64}","page":"API","title":"ClassicalSpinMC.rotateAboutAxis","text":"function rotateAboutAxis(spin::SVector{3,Float64}, axis::SVector{3,Float64}, angle::Float64)\n\nRotates a vector about an axis by a particular angle. \n\nnote: Assumptions on normalization\nThis assumes that the vector and axis are normalized  for performance reasons.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.run!","page":"API","title":"ClassicalSpinMC.run!","text":"function run!(mcs::MonteCarloExchange, outfile::Union{String,Nothing}=nothing)\n\nDispatches run to perform a Replica Exchange (Parallel Tempering) run.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClassicalSpinMC.run!-Tuple{MonteCarloAnnealing}","page":"API","title":"ClassicalSpinMC.run!","text":"function run!(mcs::MonteCarloAnnealing; outfile::Union{String,Nothing}=nothing)\n\nDispatches run to perform a Simulated Annealing run.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.run!-Union{Tuple{C}, Tuple{T}, Tuple{MonteCarlo{T}, Vector{Float64}, Array{Distributed.RemoteChannel{Channel{C}}, 1}, Array{Distributed.RemoteChannel{Channel{C}}, 1}}, Tuple{MonteCarlo{T}, Vector{Float64}, Array{Distributed.RemoteChannel{Channel{C}}, 1}, Array{Distributed.RemoteChannel{Channel{C}}, 1}, Union{Nothing, String}}} where {T<:Lattice, C}","page":"API","title":"ClassicalSpinMC.run!","text":"function run!(mc::MonteCarlo{T}, betas::Vector{Float64}, channelsUp::Vector{RemoteChannel{Channel{C}}},\nchannelsDown::Vector{RemoteChannel{Channel{C}}},\n\nInternal function used for parallel tempering runs.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.run!-Union{Tuple{MonteCarlo{T}}, Tuple{T}} where T<:Lattice","page":"API","title":"ClassicalSpinMC.run!","text":"function run!(mc::MonteCarlo{T}; outfile::Union{String,Nothing}=nothing) where {T<:Lattice}\n\nDispatches run to perform a fixed-temperature Monte Carlo run.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.sanityChecks-Union{Tuple{MonteCarlo{T}}, Tuple{T}, Tuple{MonteCarlo{T}, Union{Nothing, String}}} where T<:Lattice","page":"API","title":"ClassicalSpinMC.sanityChecks","text":"function sanityChecks(mc::MonteCarlo{T}, outfile::Union{String,Nothing}=nothing) where {T<:Lattice}\n\nPerform sanity checks on a MonteCarlo struct to prevent undefined behaviour during the run.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.setField!-Union{Tuple{D}, Tuple{UnitCell{D}, Int64, SVector{3, Float64}}} where D","page":"API","title":"ClassicalSpinMC.setField!","text":"function setField!(unitcell::UnitCell{D}, b::Int, B::SVector{3,Float64}) where {D}\n\nSets the magnetic field for a spin at the basis site 'b'.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.setField!-Union{Tuple{D}, Tuple{UnitCell{D}, Vector{SVector{3, Float64}}}} where D","page":"API","title":"ClassicalSpinMC.setField!","text":"function setField!(unitcell::UnitCell{D}, B::Vector{SVector{3,Float64}}) where {D}\n\nSets the magnetic field for all spins of the given unitcell. \n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.setInteractionOnsite!-Union{Tuple{D}, Tuple{UnitCell{D}, Int64, SMatrix{3, 3, Float64, 9}}} where D","page":"API","title":"ClassicalSpinMC.setInteractionOnsite!","text":"function setInteractionOnsite!(unitcell::UnitCell{D}, b::Int, M::SMatrix{3,3,Float64,9}) where {D}\n\nSets the self-interaction for a spin located at basis site 'b' of the given 'unitcell'.  The exchange energy is calculated as spin'.M.spin\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.setInteractionOnsite!-Union{Tuple{D}, Tuple{UnitCell{D}, Vector{SMatrix{3, 3, Float64, 9}}}} where D","page":"API","title":"ClassicalSpinMC.setInteractionOnsite!","text":"function setInteractionOnsite!(unitcell::UnitCell{D}, M::Vector{SMatrix{3,3,Float64,9}}) where {D}\n\nSets the self-interaction for all spins of the given 'unitcell'. \n\nThe exchange energy for each spin is calculated as spins'[i].M[i].spins[i]\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.setSpin!-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Int64, SVector{3, Float64}}} where {D, N}","page":"API","title":"ClassicalSpinMC.setSpin!","text":"function setSpin!(lattice::Lattice{D,N}, site::Int, newState::SVector{3,Float64}) where {D,N}\n\nInterface function to set the spin at a particular site.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.setSpin!-Union{Tuple{N}, Tuple{D}, Tuple{Lattice{D, N}, Int64, Tuple{Float64, Float64, Float64}}} where {D, N}","page":"API","title":"ClassicalSpinMC.setSpin!","text":"function setSpin!(lattice::Lattice{D,N}, site::Int, newState::NTuple{3,Float64}) where {D,N}\n\nConvenience function that converts a NTuple into SVector internally.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.sphericalUpdate","page":"API","title":"ClassicalSpinMC.sphericalUpdate","text":"function sphericalUpdate(rng=Random.GLOBAL_RNG)\n\nGenerates a random point on a unit sphere using cylindrical co-ordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClassicalSpinMC.updateTotalStatistics!-Tuple{MonteCarloStatistics}","page":"API","title":"ClassicalSpinMC.updateTotalStatistics!","text":"function updateTotalStatistics!(statistics::MonteCarloStatistics)\n\nUpdates the running total of statistics while resetting statistics from the current sweep.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.writeCheckpoint!-Union{Tuple{O}, Tuple{P}, Tuple{T}, Tuple{String, MonteCarlo{T, P, O}}} where {T<:Lattice, P<:MonteCarloParameters, O<:AbstractObservables}","page":"API","title":"ClassicalSpinMC.writeCheckpoint!","text":"function writeCheckpoint!(filename::String, mc::MonteCarlo{Lattice{D,N}}) where {D,N}\n\nInterface function to write a MonteCarlo checkpoint.\n\nwarning: Checkpoints\nCheckpoints use Serialization and thus are not recommended for long term storage  as they may not be supported on a different Julia version.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.writeLattice!-Union{Tuple{N}, Tuple{D}, Tuple{Union{HDF5.File, HDF5.Group}, Lattice{D, N}}} where {D, N}","page":"API","title":"ClassicalSpinMC.writeLattice!","text":"function writeLattice!(fn::H5, lattice::Lattice{D,N}) where {D,N}\n\nWrites the Lattice in a H5 object.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.writeMonteCarlo!-Tuple{String, MonteCarlo}","page":"API","title":"ClassicalSpinMC.writeMonteCarlo!","text":"function writeMonteCarlo!(filename::String, mc::MonteCarlo)\n\nWrites the MonteCarlo object into a HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.writeMonteCarlo!-Tuple{Union{HDF5.File, HDF5.Group}, MonteCarlo}","page":"API","title":"ClassicalSpinMC.writeMonteCarlo!","text":"function writeMonteCarlo!(fn::H5, mc::MonteCarlo)\n\nWrites the MonteCarlo object in a H5 object.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.writeMonteCarloParameters!-Union{Tuple{U}, Tuple{Union{HDF5.File, HDF5.Group}, MonteCarloParameters{U}}} where U","page":"API","title":"ClassicalSpinMC.writeMonteCarloParameters!","text":"function writeMonteCarloParameters!(fn::H5, mcp::MonteCarloParameters{U}) where {U}\n\nWrites the MonteCarloParameters in a H5 object.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.writeMonteCarloStatistics!-Tuple{Union{HDF5.File, HDF5.Group}, MonteCarloStatistics}","page":"API","title":"ClassicalSpinMC.writeMonteCarloStatistics!","text":"function writeMonteCarloStatistics!(fn::H5, mcs::MonteCarloStatistics)\n\nWrites the MonteCarloStatistics in a H5 object.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.writeObservables!-Union{Tuple{O}, Tuple{Union{HDF5.File, HDF5.Group}, O}} where O<:AbstractObservables","page":"API","title":"ClassicalSpinMC.writeObservables!","text":"function writeObservables!(fn::Union{HDF5.File,HDF5.Group}, obs::Observables)\n\nWrites the built-in Observables in a H5 object.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClassicalSpinMC.writeUnitcell!-Union{Tuple{D}, Tuple{Union{HDF5.File, HDF5.Group}, UnitCell{D}}} where D","page":"API","title":"ClassicalSpinMC.writeUnitcell!","text":"function writeUnitcell!(fn::H5, uc::UnitCell{D}) where {D}\n\nWrites the unitcell in a H5 object.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we showcase a few examples to demonstrate the  use of this package.","category":"page"},{"location":"examples/#Defining-a-lattice-spin-model","page":"Examples","title":"Defining a lattice spin model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"As an example","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ClassicalSpinMC\n\n#Create a unitcell from primitive lattice vectors aâ and aâ.\naâ=(3/2, sqrt(3)/2)\naâ=(3/2, -sqrt(3)/2)\nuc = UnitCell(aâ,aâ) \n\n#Add two basis sites to the unit cell at positions (0,0) and (1,0), respectively. \naddBasisSite!(uc, (0.0, 0.0))\naddBasisSite!(uc, (1.0, 0.0)) \n\n#Add antiferromagnetic Heisenberg interactions between nearest neighbors.\nM = [1.0 0.0 0.0;\n    0.0 1.0 0.0;\n    0.0 0.0 1.0] # Heisenberg interaction matrix\n\n#Interaction of basis site 1 with site 2 in the same unit cell\naddInteraction!(uc, 1=>2, M, (0, 0)) \n\n#Interaction of basis site 1 with site 2 in the unit cell shifted by (-1, 0) lattice vectors.\naddInteraction!(uc, 1=>2, M, (-1, 0)) \n\n#Interaction of basis site b1 with site b2 in the unit cell shifted by (0, -1) lattice vectors.\naddInteraction!(uc, 1=>2, M, (0, -1)) \n\n#Optionally apply a magnetic field B=(1,1,1) to basis site 1. \n#setField!(uc, 1, [1.0, 1.0, 1.0])\n\n#Generate a lattice of 16*16 unit cells. \nL = (16, 16)\nlattice = Lattice(uc, L)","category":"page"},{"location":"#ClassicalSpinMC.jl","page":"ClassicalSpinMC.jl","title":"ClassicalSpinMC.jl","text":"","category":"section"},{"location":"","page":"ClassicalSpinMC.jl","title":"ClassicalSpinMC.jl","text":"Markov chain Monte Carlo for  classical lattice spin models","category":"page"},{"location":"","page":"ClassicalSpinMC.jl","title":"ClassicalSpinMC.jl","text":"This package aims to provide a flexible and performant implementation of the MCMC algorithm for classical lattice spin models. This project is a fork of SpinMC.jl","category":"page"},{"location":"#Package-features-at-a-glance","page":"ClassicalSpinMC.jl","title":"Package features at a glance","text":"","category":"section"},{"location":"","page":"ClassicalSpinMC.jl","title":"ClassicalSpinMC.jl","text":"Simulated annealing.\nReplica exchange / Parallel tempering.\nArbitrary D-dimensional lattices.\nMicrocanonical / Over relaxation sweeps.\nConical spin-flip updates.\nSupports user-defined update methods and observables\nData storage in HDF5 format.","category":"page"},{"location":"#Brief-overview","page":"ClassicalSpinMC.jl","title":"Brief overview","text":"","category":"section"},{"location":"","page":"ClassicalSpinMC.jl","title":"ClassicalSpinMC.jl","text":"The package can simulate spin models described by the Hamiltonian,\nH=sum_ij S_i cdot M_ij cdot S_j + sum_i S_i cdot B_j + A(S_i)\nHere S_i are classical O(3) spins, with interactions M,  magnetic field B and an arbitrary anisotropy function A.","category":"page"},{"location":"","page":"ClassicalSpinMC.jl","title":"ClassicalSpinMC.jl","text":"By default, the package has the following methods for updating spins.","category":"page"},{"location":"","page":"ClassicalSpinMC.jl","title":"ClassicalSpinMC.jl","text":"Marsaglia method.\nCylindrical co-ordinates.\nConical updates.","category":"page"},{"location":"","page":"ClassicalSpinMC.jl","title":"ClassicalSpinMC.jl","text":"Conical updates sample around the current position of the spin on the unit sphere to maintain an acceptance rate of 50% thereby allowing for significantly reduced auto-correlation time for low temperature measurements. ","category":"page"},{"location":"","page":"ClassicalSpinMC.jl","title":"ClassicalSpinMC.jl","text":"The statistics for the measurements are provided using the BinningAnalysis.jl package. By default, the package measures energy, specific heat,  magnetization and spin-spin correlation. This behavior can be extended, please see ... for this.","category":"page"},{"location":"","page":"ClassicalSpinMC.jl","title":"ClassicalSpinMC.jl","text":"For better tempering, the package implements simulated annealing  and parallel tempering. The latter of which uses Distributed.jl allowing the sampling of large number of temperature points across multiple machines such  as on a cluster.","category":"page"},{"location":"","page":"ClassicalSpinMC.jl","title":"ClassicalSpinMC.jl","text":"Pages =[\n    \"examples.md\",\n    \"api.md\",\n]\nDepth = 2","category":"page"}]
}
